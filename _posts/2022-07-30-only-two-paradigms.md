---
title: 사실 프로프래밍 패러다임은 딱 2개 뿐이다?
updated: 2022-07-30 19:20
---

프로그래밍 언어를 배우다보면 참 많은 프로그래밍 패러다임이 있음을 알게된다.

### 명령형, 선언형, 함수형, 객체지향 등등 참 다양하다.

고백컨대 나는 얘네들이 정확히 무엇인지 잘 모른다. 그냥 이런게 있다더라 하는 정도만 안다.   
그래서 프로그래밍 패러다임에 대해 이렇다 저렇다 말하기 조심스럽긴 하지만 그래도 나의 짧은 생각을 적어보려 한다.    
그러니 그냥 '아 이렇게 생각하는 사람도 있구나' 하는 정도로 읽어주면 좋겠다.

* * *

내가 생각하기에 사실 프로그래밍 패러다임은   
### 명령형, 함수형 2개가 전부다

프로그래밍 언어의 기원이 오직 2개 뿐이기 때문에 그렇다.   
모든 프로그래밍 언어는 **튜링 머신** 혹은 **람다 대수**로 부터 기원한다.   

* * *

###  **튜링 머신**은 **명령형** 프로그래밍의 기원이 된다.   

현대의 모든 컴퓨터는 거의 다 *폰노이만 아키텍쳐* 컴퓨터다.   
*폰노이만 아키텍쳐* 컴퓨터는 결국 **튜링 머신**을 작동시키기 위한 기계장치이다.   

그렇기 때문에 *폰노이만 아키텍쳐* 컴퓨터를 작동시키기 위한 목적으로 만들어진 프로그래밍 언어들은 대부분 **튜링 머신**과 다르지 않으며, **튜링 머신**이 갖는 특성을 그대로 공유한다.   

### 그렇다면 **튜링 머신**이 갖는 특성은 무엇인가?

**튜링 머신**은 **실행흐름**, **테이프**, **명령**, **상태** 가 존재하며 다음 순서대로 동작한다.

1. **테이프**에 **명령**과 **상태**가 기록되어 있다.
2. **실행흐름**에 따라 **테이프**에 있는 **명령**을 차례대로 실행한다.
3. 실행결과에 따라 **테이프**에 있는 **상태**를 수정한다.


결국 다음 방식대로 동작하는 것이 **튜링 머신**의 특성이라고 할 수 있다.

**튜링 머신**은 **실행흐름**에 따라 **명령**을 실행하고 **상태**를 수정하는 작업을 반복한다.

### **명령형**이 갖는 특성은 **튜링 머신**이 갖는 특성을 그대로 이어 받는다.

**명령형**과 **튜링 머신**의 특성을 1:1로 대응시켜 보면 다음과 같다.   

|튜링머신|명령형|
|:-------|:-------|
|실행흐름|실행흐름|
|테이프|메모리|
|상태|변수|
|명령|연산, 대입, 흐름제어 등|

위 표에서 볼 수 있듯 **명령형**은 **튜링 머신**으로부터 특성을 그대로 이어받았다.

### **명령형**은 제어문이 있다.

어떤 언어가 **명령형**인지 판단 할 때 쉬운 방법은 **제어문**(조건문, 반복문, GOTO 등)이 있는냐 하는 것이다.   
튜링 머신처럼 명령형은 **실행흐름**이 있고, 이 **실행흐름을 제어하기 위한 제어문**이 필요하기 때문이다.

이 방법에 따라보면 기계어, 어셈블리, C언어, C++, Java, python 등은 모두 **명령형** 프로그래밍 언어라고 볼 수 있다.

C++, Java 가 **명령형**이라고? 걔네는 **객체지향** 아님?  
### 객체지향은 명령형의 발전일 뿐이다.
내 생각에 **객체지향**은 명령형에 **클래스 중심의 시각**과 **다형성**을 추가한 것일 뿐 **명령형**의 특성을 벗어나지 않았다. 

그러므로 나는 **객체지향**은 **명령형의 발전**이라고 본다. (아닐수도 있다ㅎ)


* * *

### **람다 대수**는 **함수형** 프로그래밍의 기원이 된다.   

수학 이론 **람다 대수**는 현대 컴퓨터의 기원이 된 **튜링 머신**과 동치이다.   
**튜링 머신**으로 할 수 있는 것은 모두 **람다 대수**로 할 수 있다는 얘기다. 수학적으로 증명되어 있다.

이 **람다 대수**를 기반으로 만들어진 것이 **함수형** 프로그래밍 언어다.   
그래서 **함수형** 프로그래밍 언어는 **튜링 머신**을 기반으로 설계하지 않았음에도 현대 컴퓨터를 작동시키는데 부족함이 없다. **람다 대수**와 **튜링 머신**은 동치이기 때문에.

**람다 대수**는 다음과 같은 특성을 갖는다.
1. **함수를 선언**한다.
2. 함수에 **입력값**을 주어 함수를 수행한다.
3. 수행한 함수로부터 **출력값**이 나온다.

**함수형** 언어의 특징은 **람대 대수**와 정확히 일치한다. 그래서 함수형 언어는   
1. **함수 선언**은 있지만, **실행흐름**은 없다.
2. **입력값(parameter)**은 있지만, **변수(variable)**는 없다.
3. 상태를 수정하는 대신, **출력값**을 반환한다.

### **함수형**은 제어문이 없다.

**함수형**은 실행흐름이 없기 때문에 **실행흐름을 제어하가 위한 제어문 역시 없다.**    
  
**제어문 없이 프로그래밍이 가능하다고?**   
정말 놀랍게도 가능하다. 이게 된다.

lisp이나 clojure에도 if가 있다.   
하지만 **제어문이 아니고 함수**이다.   
명령형의 조건문 if와는 **이름만 같을 뿐 전혀 다른 개념이다.**(역할은 같다)   
이론적으로는 [Church Booleans](https://opendsa-server.cs.vt.edu/OpenDSA/Books/PL/html/ChurchNumerals.html)를 이용해 구현한 함수이다. 제어문이 아니다.

* * *

모든 프로그래밍 언어는 **튜링 머신** 혹은 **람다 대수**로 부터 기원한다. 

그러므로 프로그래밍 패러다임은   
**튜링 머신**에서 기원한 **명령형**과   
**람대 대수**에서 기원한 **함수형** 뿐이다.   

그 외 패러다임들은 모두 **명령형**, **함수형**의 *발전 혹은 변형*일 뿐이지 않을까?